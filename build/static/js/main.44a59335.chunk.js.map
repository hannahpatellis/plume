{"version":3,"sources":["App.js","registerServiceWorker.js","index.js"],"names":["Group","props","className","Card","Content","header","groupName","description","studentNames","map","name","Timer","timerInput","placeholder","onChange","inputChangeTimerTime","value","initialInput","id","type","onClick","handleTimerCountClick","style","fontSize","minutes","seconds","Button","fluid","color","buttonColor","handleTimerButton","timerButton","SortBuddy","Input","icon","Icon","inverted","circular","link","handleMakeGroupsButton","handleNumberChange","numInGroups","App","state","groupNames","process","initialMin","initialSec","tick","min","Math","floor","secondsRemaining","sec","setState","clearInterval","intervalHandle","handleStartTimer","handleStopTimer","setInterval","time","handleTimerInputChange","e","target","shuffle","array","temporaryValue","randomIndex","currentIndex","length","random","newVal","randomArr","randomGroupNames","parseInt","processArr","count","totalRemaining","tempArr","remainderArr","i","push","includes","inputTime","this","val","Component","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","catch","error","ReactDom","render","document","getElementById","URL","origin","addEventListener","fetch","response","status","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.44a59335.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport { Button, Input, Icon, Card } from 'semantic-ui-react';\n\nconst Group = props => (\n  <div className='group-holder'>\n    <Card>\n      <Card.Content header={props.groupName} />\n      <Card.Content description={props.studentNames.map(name => <p>{name}</p>)} />\n    </Card>\n  </div>\n);\n\nconst Timer = (props) => (\n  <div className='timer-holder'>\n    {props.timerInput ? (\n      <input placeholder=\"0m\" onChange={props.inputChangeTimerTime} value={props.initialInput} id=\"incoming-time\" type=\"text\" />\n    ) : (\n      <h1 onClick={props.handleTimerCountClick} style={{ fontSize: 100 }}>{props.minutes}:{props.seconds}</h1>\n    )}\n    {/* <input type='number' minutes={props.minutes} onChange={props.handleTimerInputChange} required /> */}\n    \n    {/* <button >Start</button> */}\n    <Button fluid color={props.buttonColor} onClick={props.handleTimerButton}>\n      {props.timerButton}\n    </Button>\n  </div>\n);\n\nconst SortBuddy = (props) => (\n  <div className='sortbuddy-holder'>\n    <Input \n      icon={<Icon name='refresh' inverted circular link onClick={props.handleMakeGroupsButton} />}\n      onChange={props.handleNumberChange}\n      value={props.numInGroups}\n      placeholder='Number in each group' />\n  </div>\n);\n\nclass App extends Component {\n\n  state = {\n    numInGroups: 4,\n    groupNames: [\n      'ðŸ§ ðŸ¦',\n      'ðŸ•¶ðŸ¸',\n      'â˜„ï¸ðŸˆ',\n      'â›¸ðŸŒ',\n      'ðŸš€ðŸ¦•',\n      'ðŸ¦žðŸ',\n      'ðŸŒ¹ðŸ„',\n      'ðŸŠðŸŽ‰',\n      'ðŸŒ…ðŸ’Ž',\n      'ðŸ•ðŸ²',\n      'ðŸŒðŸ›',\n      'ðŸ¥¨ðŸ“Ÿ',\n      'ðŸŒµðŸ¦ˆ',\n      'ðŸŒ®ðŸ¥¯'\n    ],\n    studentNames: [\n      'Alex',\n      'Alyssa',\n      'Caleb',\n      'Charlie',\n      'Chase',\n      'Chris',\n      'Colin',\n      'Dennis',\n      'Di\\'Nasia',\n      'Felix',\n      'Jake',\n      'Jason',\n      'Jessica',\n      'John',\n      'Kanchan',\n      'Katherine',\n      'Kayla',\n      'Kristin',\n      'Lavet',\n      'Leon',\n      'Libby',\n      'Meg',\n      'Melanie',\n      'Parisa',\n      'Shelby',\n      'Stirling',\n      'Tara',\n      'Taylor',\n      'Thao'\n    ],\n    process: [],\n    minutes: '0',\n    seconds: '00',\n    initialMin: '11',\n    initialSec: '00',\n    initialInput: '',\n    timerButton: 'Start timer',\n    buttonColor: 'green',\n    timerInput: false\n  }\n\n  secondsRemaining;\n  intervalHandle;\n\n  tick = () => {\n    var min = Math.floor(this.secondsRemaining / 60);\n    var sec = this.secondsRemaining - (min * 60);\n    this.setState({\n      minutes: min,\n      seconds: sec\n    })\n    if (sec < 10) {\n      this.setState({\n        seconds: '0' + this.state.seconds,\n      })\n    }\n    if (min < 10) {\n      this.setState({\n        value: '0' + min,\n      })\n    }\n    if (min === 0 & sec === 0) {\n      clearInterval(this.intervalHandle);\n    }\n    this.secondsRemaining--;\n  }\n\n  handleTimerButton = () => {\n    if(this.state.timerButton === 'Start timer') {\n      this.handleStartTimer();\n      this.setState({ timerButton: 'Stop and reset timer', buttonColor: 'red', timerInput: false });\n    } else {\n      this.handleStopTimer();\n      this.setState({ timerButton: 'Start timer', buttonColor: 'green' });\n    }\n  }\n\n  handleStopTimer = () => {\n    clearInterval(this.intervalHandle);\n    this.setState({ minutes: this.state.initialMin, seconds: this.state.initialSec })\n  }\n\n  handleStartTimer = () => {\n    this.intervalHandle = setInterval(this.tick, 1000);\n    let time = this.state.initialInput;\n    this.secondsRemaining = time * 60;\n    this.setState({ initialMin: time })\n  }\n\n\n  handleTimerInputChange = e => {\n    this.setState({ minutes: e.target.value });\n  }\n\n  shuffle = (array) => {\n    let currentIndex = array.length, temporaryValue, randomIndex;\n\n    while (0 !== currentIndex) {\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n\n    return array;\n  }\n\n  handleNumberChange = (e) => {\n    let newVal = e.target.value;\n    this.setState({ numInGroups: newVal });\n  };\n\n  handleMakeGroupsButton = () => {\n    const randomArr = this.shuffle(this.state.studentNames);\n    const randomGroupNames = this.shuffle(this.state.groupNames);\n\n    const numInGroups = parseInt(this.state.numInGroups);\n      \n    let processArr = [];\n    let count = 0;\n    let totalRemaining = randomArr.length;\n    let tempArr = [];\n    let remainderArr = [];\n\n    for (let i = 0; i < randomArr.length; i++) {\n      if(count < numInGroups) {\n        tempArr.push(randomArr[i]);\n        count++;\n        totalRemaining--;\n      }\n      else if (count === numInGroups) { \n        processArr.push(tempArr);\n        tempArr = [];\n        tempArr.push(randomArr[i]);\n        count = 1;\n        totalRemaining--;\n      }\n\n      if (totalRemaining < numInGroups-count && !processArr.includes(randomArr[i])) {\n        remainderArr.push(randomArr[i]);\n      }\n    }\n\n    if(remainderArr.length === 1) {\n      processArr[0].push(remainderArr[0]);\n    } else if (remainderArr.length > 1){\n      processArr.push(remainderArr);\n    }\n\n    this.setState({ process: processArr, groupNames: randomGroupNames });\n  };\n\n  handleTimerCountClick = () => {\n    this.setState({ timerInput: true });\n  }\n\n  inputChangeTimerTime = (e) => {\n    let inputTime = e.target.value;\n    this.setState({ initialInput: inputTime });\n  }\n\n  componentDidMount() {\n  }\n\n  render() {\n    return (\n      <div className='app'>\n        <div className='topWrap'>\n          <Timer\n              minutes={this.state.minutes}\n              seconds={this.state.seconds}\n              handleTimerInputChange={this.handleTimerInputChange}\n              handleTimerButton={this.handleTimerButton} \n              timerButton={this.state.timerButton} \n              buttonColor={this.state.buttonColor} \n              timerInput={this.state.timerInput} \n              handleTimerCountClick={this.handleTimerCountClick} \n              inputChangeTimerTime={this.inputChangeTimerTime}\n              initialInput={this.state.initialInput} />\n          <div className='myhr'></div>\n          <SortBuddy \n            handleMakeGroupsButton={this.handleMakeGroupsButton}\n            numInGroups={this.state.numInGroups}\n            handleNumberChange={this.handleNumberChange} />\n        </div>\n        <div className='groupsWrap'>\n          {this.state.process.map((val, i) => (\n            <Group studentNames={val} groupName={this.state.groupNames[i]} />\n          ))}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log(\"New content is available; please refresh.\");\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get(\"content-type\").indexOf(\"javascript\") === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDom from 'react-dom';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDom.render(<App />, document.getElementById('react-app'));\n\nregisterServiceWorker();"],"sourceRoot":""}